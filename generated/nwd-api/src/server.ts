// @generated by
//
//   ██████╗ ██████╗ ███████╗███╗   ██╗ █████╗ ██████╗ ██╗██╗  ██╗██████╗
//  ██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔══██╗██╔══██╗██║██║  ██║╚════██╗
//  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████║██████╔╝██║███████║ █████╔╝
//  ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║██╔══██║██╔═══╝ ██║╚════██║██╔═══╝
//  ╚██████╔╝██║     ███████╗██║ ╚████║██║  ██║██║     ██║     ██║███████╗
//   ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚══════╝
//   v0.1.3                                           -- www.OpenApi42.org
import { Router } from "goodrouter";
import * as parameters from "./parameters.js";
import * as types from "./types.js";
import * as validators from "./validators.js";
import * as parsers from "./parsers.js";
import * as lib from "oa42-lib";
export interface ServerOptions {
validateIncomingEntity?: boolean;
validateIncomingParameters?: boolean;
validateOutgoingEntity?: boolean;
validateOutgoingParameters?: boolean;
}
export const defaultServerOptions = {
validateIncomingEntity: true,
validateIncomingParameters: true,
validateOutgoingEntity: false,
validateOutgoingParameters: false,
};
const router = new Router({
parameterValueDecoder: value => value,
parameterValueEncoder: value => value,
}).loadFromJson({"rootNode":{"anchor":"","hasParameter":false,"routeKey":null,"children":[{"anchor":"/echo","hasParameter":false,"routeKey":1,"children":[]}]},"templatePairs":[[1,[["/echo",null]]]]});
export type ServerAuthentication = Record<never, unknown>;
export class Server<A extends ServerAuthentication = ServerAuthentication>
extends lib.ServerBase
{
protected readonly options: ServerOptions & typeof defaultServerOptions;
constructor(options: ServerOptions = {}) {
super();
this.options = {
...defaultServerOptions,
...options,
};
}
public async routeHandler(
serverIncomingRequest: lib.ServerIncomingRequest,
): Promise<lib.ServerOutgoingResponse> {
const [pathId, pathParameters] =
router.parseRoute(serverIncomingRequest.path);
switch(pathId) {
case 1:
switch(serverIncomingRequest.method) {
case "GET":
return this.echoViaGetRouteHandler(
pathParameters,
serverIncomingRequest,
);
case "POST":
return this.echoRouteHandler(
pathParameters,
serverIncomingRequest,
);
default:
throw new lib.MethodNotSupported()
}
default:
throw new lib.NoRouteFound()
}
}
private echoViaGetOperationHandler?: EchoViaGetOperationHandler<A>;
/**
Send a message via GET and get your message back in a message-container
Send a message and get the same message back!
*/
public registerEchoViaGetOperation(operationHandler: EchoViaGetOperationHandler<A>) {
this.echoViaGetOperationHandler = operationHandler;
}
private async echoViaGetRouteHandler(
pathParameters: Record<string, string>,
serverIncomingRequest: lib.ServerIncomingRequest,
): Promise<lib.ServerOutgoingResponse> {
const {
validateIncomingEntity,
validateIncomingParameters,
validateOutgoingEntity,
validateOutgoingParameters,
} = this.options;
const cookie =
lib.getParameterValues(serverIncomingRequest.headers, "cookie");
const accept =
lib.getParameterValues(serverIncomingRequest.headers, "accept");
const requestContentType =
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "content-type"));
const queryParameters =
lib.parseParameters([serverIncomingRequest.query], "?", "&", "=");
const cookieParameters =
lib.parseParameters(cookie, "", "; ", "=");
const authentication = {
}
if(!isEchoViaGetAuthentication(authentication)) {
throw new lib.AuthenticationFailed();
}
const requestParameters = {
message:
parsers.parseParametersSchema(lib.getParameterValues(queryParameters, "message")),
} as parameters.EchoViaGetRequestParameters;
if(validateIncomingParameters) {
if(!parameters.isEchoViaGetRequestParameters(requestParameters)) {
throw new lib.ServerRequestParameterValidationFailed();
}
}
let incomingRequest: EchoViaGetIncomingRequest;
incomingRequest = {
parameters: requestParameters,
contentType: null,
};
const outgoingResponse = await this.echoViaGetOperationHandler?.(
incomingRequest,
authentication,
);
if (outgoingResponse == null) {
throw new lib.OperationNotImplemented();
}
let serverOutgoingResponse: lib.ServerOutgoingResponse ;
switch(outgoingResponse.status) {
case 200:
{
if(validateOutgoingParameters) {
if(!parameters.isEchoViaGet200ResponseParameters(outgoingResponse.parameters)) {
throw new lib.ServerResponseParameterValidationFailed();
}
}
const responseHeaders = {};
switch(outgoingResponse.contentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isGetSchema(entity)) {
throw new lib.ServerResponseEntityValidationFailed();
}
return entity as types.GetSchema;
}
lib.addParameter(responseHeaders, "content-type", outgoingResponse.contentType);
serverOutgoingResponse = {
status: outgoingResponse.status,
headers: responseHeaders,
stream(signal) {
if("stream" in outgoingResponse) {
return outgoingResponse.stream(signal);
}
else if("entities" in outgoingResponse) {
let entities = outgoingResponse.entities(signal);
if(validateOutgoingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return lib.serializeJsonEntities(outgoingResponse.entities(signal));
}
else if("entity" in outgoingResponse) {
let entity = outgoingResponse.entity();
if(validateOutgoingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return lib.serializeJsonEntity(entity);
}
else {
throw new lib.Unreachable();
}
},
}
break;
}
default:
throw new lib.Unreachable();
}
break;
}
default:
throw new lib.Unreachable();
}
return serverOutgoingResponse
}
private echoOperationHandler?: EchoOperationHandler<A>;
/**
Send a message
Send a message and get the same message back!
*/
public registerEchoOperation(operationHandler: EchoOperationHandler<A>) {
this.echoOperationHandler = operationHandler;
}
private async echoRouteHandler(
pathParameters: Record<string, string>,
serverIncomingRequest: lib.ServerIncomingRequest,
): Promise<lib.ServerOutgoingResponse> {
const {
validateIncomingEntity,
validateIncomingParameters,
validateOutgoingEntity,
validateOutgoingParameters,
} = this.options;
const cookie =
lib.getParameterValues(serverIncomingRequest.headers, "cookie");
const accept =
lib.getParameterValues(serverIncomingRequest.headers, "accept");
const requestContentType =
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "content-type"));
const queryParameters =
lib.parseParameters([serverIncomingRequest.query], "?", "&", "=");
const cookieParameters =
lib.parseParameters(cookie, "", "; ", "=");
const authentication = {
}
if(!isEchoAuthentication(authentication)) {
throw new lib.AuthenticationFailed();
}
const requestParameters = {
} as parameters.EchoRequestParameters;
if(validateIncomingParameters) {
if(!parameters.isEchoRequestParameters(requestParameters)) {
throw new lib.ServerRequestParameterValidationFailed();
}
}
let incomingRequest: EchoIncomingRequest;
if(requestContentType == null) {
throw new lib.MissingServerRequestContentType();
}
switch(requestContentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isRequestBodySchema(entity)) {
throw new lib.ServerRequestEntityValidationFailed();
}
return entity;
};
incomingRequest = {
parameters: requestParameters,
contentType: requestContentType,
stream(signal) {
return serverIncomingRequest.stream(signal);
},
entities(signal) {
let entities = lib.deserializeJsonEntities(
serverIncomingRequest.stream,
signal,
) as AsyncIterable<types.RequestBodySchema>;
if(validateIncomingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return entities;
},
entity() {
let entity = lib.deserializeJsonEntity(
serverIncomingRequest.stream
) as Promise<types.RequestBodySchema>;
if(validateIncomingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return entity;
},
};
break;
}
default:
throw new lib.UnexpectedServerRequestContentType();
;
}
const outgoingResponse = await this.echoOperationHandler?.(
incomingRequest,
authentication,
);
if (outgoingResponse == null) {
throw new lib.OperationNotImplemented();
}
let serverOutgoingResponse: lib.ServerOutgoingResponse ;
switch(outgoingResponse.status) {
case 200:
{
if(validateOutgoingParameters) {
if(!parameters.isEcho200ResponseParameters(outgoingResponse.parameters)) {
throw new lib.ServerResponseParameterValidationFailed();
}
}
const responseHeaders = {};
switch(outgoingResponse.contentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isPostSchema(entity)) {
throw new lib.ServerResponseEntityValidationFailed();
}
return entity as types.PostSchema;
}
lib.addParameter(responseHeaders, "content-type", outgoingResponse.contentType);
serverOutgoingResponse = {
status: outgoingResponse.status,
headers: responseHeaders,
stream(signal) {
if("stream" in outgoingResponse) {
return outgoingResponse.stream(signal);
}
else if("entities" in outgoingResponse) {
let entities = outgoingResponse.entities(signal);
if(validateOutgoingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return lib.serializeJsonEntities(outgoingResponse.entities(signal));
}
else if("entity" in outgoingResponse) {
let entity = outgoingResponse.entity();
if(validateOutgoingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return lib.serializeJsonEntity(entity);
}
else {
throw new lib.Unreachable();
}
},
}
break;
}
default:
throw new lib.Unreachable();
}
break;
}
default:
throw new lib.Unreachable();
}
return serverOutgoingResponse
}
}
export function isEchoViaGetAuthentication<A extends ServerAuthentication>(
authentication: Partial<EchoViaGetAuthentication<A>>,
): authentication is EchoViaGetAuthentication<A> {
// TODO
return true;
}
export type EchoViaGetAuthentication<A extends ServerAuthentication> =
{}
;
export type EchoViaGetOperationHandler<A extends ServerAuthentication> =
(
incomingRequest: EchoViaGetIncomingRequest,
authentication: EchoViaGetAuthentication<A>,
) => EchoViaGetOutgoingResponse | Promise<EchoViaGetOutgoingResponse>
export type EchoViaGetIncomingRequest =
lib.IncomingEmptyRequest<parameters.EchoViaGetRequestParameters>
;
export type EchoViaGetOutgoingResponse =
lib.OutgoingJsonResponse<
200,
parameters.EchoViaGet200ResponseParameters,
"application/json",
types.GetSchema
>
;
export function isEchoAuthentication<A extends ServerAuthentication>(
authentication: Partial<EchoAuthentication<A>>,
): authentication is EchoAuthentication<A> {
// TODO
return true;
}
export type EchoAuthentication<A extends ServerAuthentication> =
{}
;
export type EchoOperationHandler<A extends ServerAuthentication> =
(
incomingRequest: EchoIncomingRequest,
authentication: EchoAuthentication<A>,
) => EchoOutgoingResponse | Promise<EchoOutgoingResponse>
export type EchoIncomingRequest =
lib.IncomingJsonRequest<
parameters.EchoRequestParameters,
"application/json",
types.RequestBodySchema
>
;
export type EchoOutgoingResponse =
lib.OutgoingJsonResponse<
200,
parameters.Echo200ResponseParameters,
"application/json",
types.PostSchema
>
;
