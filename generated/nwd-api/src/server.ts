// @generated by
//
//   ██████╗ ██████╗ ███████╗███╗   ██╗ █████╗ ██████╗ ██╗██╗  ██╗██████╗
//  ██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔══██╗██╔══██╗██║██║  ██║╚════██╗
//  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████║██████╔╝██║███████║ █████╔╝
//  ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║██╔══██║██╔═══╝ ██║╚════██║██╔═══╝
//  ╚██████╔╝██║     ███████╗██║ ╚████║██║  ██║██║     ██║     ██║███████╗
//   ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚══════╝
//   v0.2.1                                           -- www.OpenApi42.org
import { Router } from "goodrouter";
import * as parameters from "./parameters.js";
import * as types from "./types.js";
import * as validators from "./validators.js";
import * as parsers from "./parsers.js";
import * as lib from "oa42-lib";
export interface ServerOptions {
validateIncomingEntity?: boolean;
validateIncomingParameters?: boolean;
validateOutgoingEntity?: boolean;
validateOutgoingParameters?: boolean;
}
export const defaultServerOptions = {
validateIncomingEntity: true,
validateIncomingParameters: true,
validateOutgoingEntity: false,
validateOutgoingParameters: false,
};
const router = new Router({
parameterValueDecoder: value => value,
parameterValueEncoder: value => value,
}).loadFromJson({"rootNode":{"anchor":"","hasParameter":false,"routeKey":null,"children":[{"anchor":"/","hasParameter":false,"routeKey":null,"children":[{"anchor":"main-category","hasParameter":false,"routeKey":1,"children":[]},{"anchor":"sub-category/","hasParameter":false,"routeKey":null,"children":[{"anchor":"","hasParameter":true,"routeKey":2,"children":[]}]}]}]},"templatePairs":[[1,[["/main-category",null]]],[2,[["/sub-category/",null],["","main-category-id"]]]]});
export type ServerAuthentication = Record<"apiToken", unknown>;
export class Server<A extends ServerAuthentication = ServerAuthentication>
extends lib.ServerBase
{
protected readonly options: ServerOptions & typeof defaultServerOptions;
constructor(options: ServerOptions = {}) {
super();
this.options = {
...defaultServerOptions,
...options,
};
}
public async routeHandler(
serverIncomingRequest: lib.ServerIncomingRequest,
): Promise<lib.ServerOutgoingResponse> {
const [pathId, pathParameters] =
router.parseRoute(serverIncomingRequest.path);
switch(pathId) {
case 1:
switch(serverIncomingRequest.method) {
case "GET":
return this.getMainCategoriesRouteHandler(
pathParameters,
serverIncomingRequest,
);
case "POST":
return this.createMainCategoryRouteHandler(
pathParameters,
serverIncomingRequest,
);
default:
throw new lib.MethodNotSupported()
}
case 2:
switch(serverIncomingRequest.method) {
case "GET":
return this.getSubCategoriesRouteHandler(
pathParameters,
serverIncomingRequest,
);
case "POST":
return this.createSubCategoryRouteHandler(
pathParameters,
serverIncomingRequest,
);
default:
throw new lib.MethodNotSupported()
}
default:
throw new lib.NoRouteFound()
}
}
private apiTokenAuthenticationHandler?: ApiTokenAuthenticationHandler<A>;
public registerApiTokenAuthentication(authenticationHandler: ApiTokenAuthenticationHandler<A>) {
this.apiTokenAuthenticationHandler = authenticationHandler;
}
private getMainCategoriesOperationHandler?: GetMainCategoriesOperationHandler<A>;
/**
Get main get-main-categories
*/
public registerGetMainCategoriesOperation(operationHandler: GetMainCategoriesOperationHandler<A>) {
this.getMainCategoriesOperationHandler = operationHandler;
}
private async getMainCategoriesRouteHandler(
pathParameters: Record<string, string>,
serverIncomingRequest: lib.ServerIncomingRequest,
): Promise<lib.ServerOutgoingResponse> {
const {
validateIncomingEntity,
validateIncomingParameters,
validateOutgoingEntity,
validateOutgoingParameters,
} = this.options;
const cookie =
lib.getParameterValues(serverIncomingRequest.headers, "cookie");
const accept =
lib.getParameterValues(serverIncomingRequest.headers, "accept");
const requestContentType =
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "content-type"));
const queryParameters =
lib.parseParameters([serverIncomingRequest.query], "?", "&", "=");
const cookieParameters =
lib.parseParameters(cookie, "", "; ", "=");
const credentials = {
apiToken:
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "api-token")),
}
const authentication: A = Object.fromEntries(
await Promise.all([
(
async () => [
"apiToken",
credentials.apiToken == null ?
undefined :
await this.apiTokenAuthenticationHandler?.(credentials.apiToken)
]
)(),
]),
);
if(!isGetMainCategoriesAuthentication(authentication)) {
throw new lib.AuthenticationFailed();
}
const requestParameters = {
} as parameters.GetMainCategoriesRequestParameters;
if(validateIncomingParameters) {
if(!parameters.isGetMainCategoriesRequestParameters(requestParameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerRequestParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule
);
}
}
let incomingRequest: GetMainCategoriesIncomingRequest;
incomingRequest = {
parameters: requestParameters,
contentType: null,
};
const outgoingResponse = await this.getMainCategoriesOperationHandler?.(
incomingRequest,
authentication,
);
if (outgoingResponse == null) {
throw new lib.OperationNotImplemented();
}
let serverOutgoingResponse: lib.ServerOutgoingResponse ;
switch(outgoingResponse.status) {
case 200:
{
if(validateOutgoingParameters) {
if(!parameters.isGetMainCategories200ResponseParameters(outgoingResponse.parameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerResponseParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule,
);
}
}
const responseHeaders = {};
switch(outgoingResponse.contentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isMainCategory200GetSchema(entity)) {
const lastError = validators.getLastValidationError();
throw new lib.ServerResponseEntityValidationFailed(
lastError.path,
lastError.rule,
);
}
return entity as types.MainCategory200GetSchema;
}
lib.addParameter(responseHeaders, "content-type", outgoingResponse.contentType);
serverOutgoingResponse = {
status: outgoingResponse.status,
headers: responseHeaders,
stream(signal) {
if("stream" in outgoingResponse) {
return outgoingResponse.stream(signal);
}
else if("entities" in outgoingResponse) {
let entities = outgoingResponse.entities(signal);
if(validateOutgoingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return lib.serializeJsonEntities(outgoingResponse.entities(signal));
}
else if("entity" in outgoingResponse) {
let entity = outgoingResponse.entity();
if(validateOutgoingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return lib.serializeJsonEntity(entity);
}
else {
throw new lib.Unreachable();
}
},
}
break;
}
default:
throw new lib.Unreachable();
}
break;
}
default:
throw new lib.Unreachable();
}
return serverOutgoingResponse
}
private createMainCategoryOperationHandler?: CreateMainCategoryOperationHandler<A>;
/**
Create an new main category
*/
public registerCreateMainCategoryOperation(operationHandler: CreateMainCategoryOperationHandler<A>) {
this.createMainCategoryOperationHandler = operationHandler;
}
private async createMainCategoryRouteHandler(
pathParameters: Record<string, string>,
serverIncomingRequest: lib.ServerIncomingRequest,
): Promise<lib.ServerOutgoingResponse> {
const {
validateIncomingEntity,
validateIncomingParameters,
validateOutgoingEntity,
validateOutgoingParameters,
} = this.options;
const cookie =
lib.getParameterValues(serverIncomingRequest.headers, "cookie");
const accept =
lib.getParameterValues(serverIncomingRequest.headers, "accept");
const requestContentType =
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "content-type"));
const queryParameters =
lib.parseParameters([serverIncomingRequest.query], "?", "&", "=");
const cookieParameters =
lib.parseParameters(cookie, "", "; ", "=");
const credentials = {
apiToken:
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "api-token")),
}
const authentication: A = Object.fromEntries(
await Promise.all([
(
async () => [
"apiToken",
credentials.apiToken == null ?
undefined :
await this.apiTokenAuthenticationHandler?.(credentials.apiToken)
]
)(),
]),
);
if(!isCreateMainCategoryAuthentication(authentication)) {
throw new lib.AuthenticationFailed();
}
const requestParameters = {
} as parameters.CreateMainCategoryRequestParameters;
if(validateIncomingParameters) {
if(!parameters.isCreateMainCategoryRequestParameters(requestParameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerRequestParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule
);
}
}
let incomingRequest: CreateMainCategoryIncomingRequest;
if(requestContentType == null) {
throw new lib.ServerRequestMissingContentType();
}
switch(requestContentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isMainCategoryPostRequestBodySchema(entity)) {
const lastError = validators.getLastValidationError();
throw new lib.ServerRequestEntityValidationFailed(
lastError.path,
lastError.rule,
);
}
return entity;
};
incomingRequest = {
parameters: requestParameters,
contentType: requestContentType,
stream(signal) {
return serverIncomingRequest.stream(signal);
},
entities(signal) {
let entities = lib.deserializeJsonEntities(
serverIncomingRequest.stream,
signal,
) as AsyncIterable<types.MainCategoryPostRequestBodySchema>;
if(validateIncomingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return entities;
},
entity() {
let entity = lib.deserializeJsonEntity(
serverIncomingRequest.stream
) as Promise<types.MainCategoryPostRequestBodySchema>;
if(validateIncomingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return entity;
},
};
break;
}
default:
throw new lib.ServerRequestUnexpectedContentType();
;
}
const outgoingResponse = await this.createMainCategoryOperationHandler?.(
incomingRequest,
authentication,
);
if (outgoingResponse == null) {
throw new lib.OperationNotImplemented();
}
let serverOutgoingResponse: lib.ServerOutgoingResponse ;
switch(outgoingResponse.status) {
case 201:
{
if(validateOutgoingParameters) {
if(!parameters.isCreateMainCategory201ResponseParameters(outgoingResponse.parameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerResponseParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule,
);
}
}
const responseHeaders = {};
switch(outgoingResponse.contentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isMainCategoryPost201Schema(entity)) {
const lastError = validators.getLastValidationError();
throw new lib.ServerResponseEntityValidationFailed(
lastError.path,
lastError.rule,
);
}
return entity as types.MainCategoryPost201Schema;
}
lib.addParameter(responseHeaders, "content-type", outgoingResponse.contentType);
serverOutgoingResponse = {
status: outgoingResponse.status,
headers: responseHeaders,
stream(signal) {
if("stream" in outgoingResponse) {
return outgoingResponse.stream(signal);
}
else if("entities" in outgoingResponse) {
let entities = outgoingResponse.entities(signal);
if(validateOutgoingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return lib.serializeJsonEntities(outgoingResponse.entities(signal));
}
else if("entity" in outgoingResponse) {
let entity = outgoingResponse.entity();
if(validateOutgoingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return lib.serializeJsonEntity(entity);
}
else {
throw new lib.Unreachable();
}
},
}
break;
}
default:
throw new lib.Unreachable();
}
break;
}
case 403:
{
if(validateOutgoingParameters) {
if(!parameters.isCreateMainCategory403ResponseParameters(outgoingResponse.parameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerResponseParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule,
);
}
}
const responseHeaders = {};
serverOutgoingResponse = {
status: outgoingResponse.status,
headers: responseHeaders,
}
break;
}
default:
throw new lib.Unreachable();
}
return serverOutgoingResponse
}
private getSubCategoriesOperationHandler?: GetSubCategoriesOperationHandler<A>;
/**
Get sub categories in a main category
*/
public registerGetSubCategoriesOperation(operationHandler: GetSubCategoriesOperationHandler<A>) {
this.getSubCategoriesOperationHandler = operationHandler;
}
private async getSubCategoriesRouteHandler(
pathParameters: Record<string, string>,
serverIncomingRequest: lib.ServerIncomingRequest,
): Promise<lib.ServerOutgoingResponse> {
const {
validateIncomingEntity,
validateIncomingParameters,
validateOutgoingEntity,
validateOutgoingParameters,
} = this.options;
const cookie =
lib.getParameterValues(serverIncomingRequest.headers, "cookie");
const accept =
lib.getParameterValues(serverIncomingRequest.headers, "accept");
const requestContentType =
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "content-type"));
const queryParameters =
lib.parseParameters([serverIncomingRequest.query], "?", "&", "=");
const cookieParameters =
lib.parseParameters(cookie, "", "; ", "=");
const credentials = {
apiToken:
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "api-token")),
}
const authentication: A = Object.fromEntries(
await Promise.all([
(
async () => [
"apiToken",
credentials.apiToken == null ?
undefined :
await this.apiTokenAuthenticationHandler?.(credentials.apiToken)
]
)(),
]),
);
if(!isGetSubCategoriesAuthentication(authentication)) {
throw new lib.AuthenticationFailed();
}
const requestParameters = {
mainCategoryId:
parsers.parseParametersSchema(lib.getParameterValues(pathParameters, "main-category-id")),
} as parameters.GetSubCategoriesRequestParameters;
if(validateIncomingParameters) {
if(!parameters.isGetSubCategoriesRequestParameters(requestParameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerRequestParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule
);
}
}
let incomingRequest: GetSubCategoriesIncomingRequest;
incomingRequest = {
parameters: requestParameters,
contentType: null,
};
const outgoingResponse = await this.getSubCategoriesOperationHandler?.(
incomingRequest,
authentication,
);
if (outgoingResponse == null) {
throw new lib.OperationNotImplemented();
}
let serverOutgoingResponse: lib.ServerOutgoingResponse ;
switch(outgoingResponse.status) {
case 200:
{
if(validateOutgoingParameters) {
if(!parameters.isGetSubCategories200ResponseParameters(outgoingResponse.parameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerResponseParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule,
);
}
}
const responseHeaders = {};
switch(outgoingResponse.contentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isSubCategoryMainCategoryId200GetSchema(entity)) {
const lastError = validators.getLastValidationError();
throw new lib.ServerResponseEntityValidationFailed(
lastError.path,
lastError.rule,
);
}
return entity as types.SubCategoryMainCategoryId200GetSchema;
}
lib.addParameter(responseHeaders, "content-type", outgoingResponse.contentType);
serverOutgoingResponse = {
status: outgoingResponse.status,
headers: responseHeaders,
stream(signal) {
if("stream" in outgoingResponse) {
return outgoingResponse.stream(signal);
}
else if("entities" in outgoingResponse) {
let entities = outgoingResponse.entities(signal);
if(validateOutgoingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return lib.serializeJsonEntities(outgoingResponse.entities(signal));
}
else if("entity" in outgoingResponse) {
let entity = outgoingResponse.entity();
if(validateOutgoingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return lib.serializeJsonEntity(entity);
}
else {
throw new lib.Unreachable();
}
},
}
break;
}
default:
throw new lib.Unreachable();
}
break;
}
default:
throw new lib.Unreachable();
}
return serverOutgoingResponse
}
private createSubCategoryOperationHandler?: CreateSubCategoryOperationHandler<A>;
/**
Create an new sub category in a main category
*/
public registerCreateSubCategoryOperation(operationHandler: CreateSubCategoryOperationHandler<A>) {
this.createSubCategoryOperationHandler = operationHandler;
}
private async createSubCategoryRouteHandler(
pathParameters: Record<string, string>,
serverIncomingRequest: lib.ServerIncomingRequest,
): Promise<lib.ServerOutgoingResponse> {
const {
validateIncomingEntity,
validateIncomingParameters,
validateOutgoingEntity,
validateOutgoingParameters,
} = this.options;
const cookie =
lib.getParameterValues(serverIncomingRequest.headers, "cookie");
const accept =
lib.getParameterValues(serverIncomingRequest.headers, "accept");
const requestContentType =
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "content-type"));
const queryParameters =
lib.parseParameters([serverIncomingRequest.query], "?", "&", "=");
const cookieParameters =
lib.parseParameters(cookie, "", "; ", "=");
const credentials = {
apiToken:
lib.first(lib.getParameterValues(serverIncomingRequest.headers, "api-token")),
}
const authentication: A = Object.fromEntries(
await Promise.all([
(
async () => [
"apiToken",
credentials.apiToken == null ?
undefined :
await this.apiTokenAuthenticationHandler?.(credentials.apiToken)
]
)(),
]),
);
if(!isCreateSubCategoryAuthentication(authentication)) {
throw new lib.AuthenticationFailed();
}
const requestParameters = {
mainCategoryId:
parsers.parseParametersSchema(lib.getParameterValues(pathParameters, "main-category-id")),
} as parameters.CreateSubCategoryRequestParameters;
if(validateIncomingParameters) {
if(!parameters.isCreateSubCategoryRequestParameters(requestParameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerRequestParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule
);
}
}
let incomingRequest: CreateSubCategoryIncomingRequest;
if(requestContentType == null) {
throw new lib.ServerRequestMissingContentType();
}
switch(requestContentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isSubCategoryMainCategoryIdPostRequestBodySchema(entity)) {
const lastError = validators.getLastValidationError();
throw new lib.ServerRequestEntityValidationFailed(
lastError.path,
lastError.rule,
);
}
return entity;
};
incomingRequest = {
parameters: requestParameters,
contentType: requestContentType,
stream(signal) {
return serverIncomingRequest.stream(signal);
},
entities(signal) {
let entities = lib.deserializeJsonEntities(
serverIncomingRequest.stream,
signal,
) as AsyncIterable<types.SubCategoryMainCategoryIdPostRequestBodySchema>;
if(validateIncomingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return entities;
},
entity() {
let entity = lib.deserializeJsonEntity(
serverIncomingRequest.stream
) as Promise<types.SubCategoryMainCategoryIdPostRequestBodySchema>;
if(validateIncomingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return entity;
},
};
break;
}
default:
throw new lib.ServerRequestUnexpectedContentType();
;
}
const outgoingResponse = await this.createSubCategoryOperationHandler?.(
incomingRequest,
authentication,
);
if (outgoingResponse == null) {
throw new lib.OperationNotImplemented();
}
let serverOutgoingResponse: lib.ServerOutgoingResponse ;
switch(outgoingResponse.status) {
case 201:
{
if(validateOutgoingParameters) {
if(!parameters.isCreateSubCategory201ResponseParameters(outgoingResponse.parameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerResponseParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule,
);
}
}
const responseHeaders = {};
switch(outgoingResponse.contentType) {
case "application/json":
{
const mapAssertEntity = (entity: unknown) => {
if(!validators.isSubCategoryMainCategoryIdPost201Schema(entity)) {
const lastError = validators.getLastValidationError();
throw new lib.ServerResponseEntityValidationFailed(
lastError.path,
lastError.rule,
);
}
return entity as types.SubCategoryMainCategoryIdPost201Schema;
}
lib.addParameter(responseHeaders, "content-type", outgoingResponse.contentType);
serverOutgoingResponse = {
status: outgoingResponse.status,
headers: responseHeaders,
stream(signal) {
if("stream" in outgoingResponse) {
return outgoingResponse.stream(signal);
}
else if("entities" in outgoingResponse) {
let entities = outgoingResponse.entities(signal);
if(validateOutgoingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return lib.serializeJsonEntities(outgoingResponse.entities(signal));
}
else if("entity" in outgoingResponse) {
let entity = outgoingResponse.entity();
if(validateOutgoingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return lib.serializeJsonEntity(entity);
}
else {
throw new lib.Unreachable();
}
},
}
break;
}
default:
throw new lib.Unreachable();
}
break;
}
case 403:
{
if(validateOutgoingParameters) {
if(!parameters.isCreateSubCategory403ResponseParameters(outgoingResponse.parameters)) {
const lastError = parameters.getLastParameterValidationError();
throw new lib.ServerResponseParameterValidationFailed(
lastError.parameterName,
lastError.path,
lastError.rule,
);
}
}
const responseHeaders = {};
serverOutgoingResponse = {
status: outgoingResponse.status,
headers: responseHeaders,
}
break;
}
default:
throw new lib.Unreachable();
}
return serverOutgoingResponse
}
}
export type ApiTokenAuthenticationHandler<A extends ServerAuthentication> =
(credential: string) =>
A["apiToken"] | undefined |
Promise<A["apiToken"] | undefined>;
export function isGetMainCategoriesAuthentication<A extends ServerAuthentication>(
authentication: Partial<GetMainCategoriesAuthentication<A>>,
): authentication is GetMainCategoriesAuthentication<A> {
return authentication.apiToken !== undefined
}
export type GetMainCategoriesAuthentication<A extends ServerAuthentication> =
Pick<A, "apiToken">
;
export type GetMainCategoriesOperationHandler<A extends ServerAuthentication> =
(
incomingRequest: GetMainCategoriesIncomingRequest,
authentication: GetMainCategoriesAuthentication<A>,
) => GetMainCategoriesOutgoingResponse | Promise<GetMainCategoriesOutgoingResponse>
export type GetMainCategoriesIncomingRequest =
lib.IncomingEmptyRequest<parameters.GetMainCategoriesRequestParameters>
;
export type GetMainCategoriesOutgoingResponse =
lib.OutgoingJsonResponse<
200,
parameters.GetMainCategories200ResponseParameters,
"application/json",
types.MainCategory200GetSchema
>
;
export function isCreateMainCategoryAuthentication<A extends ServerAuthentication>(
authentication: Partial<CreateMainCategoryAuthentication<A>>,
): authentication is CreateMainCategoryAuthentication<A> {
return authentication.apiToken !== undefined
}
export type CreateMainCategoryAuthentication<A extends ServerAuthentication> =
Pick<A, "apiToken">
;
export type CreateMainCategoryOperationHandler<A extends ServerAuthentication> =
(
incomingRequest: CreateMainCategoryIncomingRequest,
authentication: CreateMainCategoryAuthentication<A>,
) => CreateMainCategoryOutgoingResponse | Promise<CreateMainCategoryOutgoingResponse>
export type CreateMainCategoryIncomingRequest =
lib.IncomingJsonRequest<
parameters.CreateMainCategoryRequestParameters,
"application/json",
types.MainCategoryPostRequestBodySchema
>
;
export type CreateMainCategoryOutgoingResponse =
lib.OutgoingJsonResponse<
201,
parameters.CreateMainCategory201ResponseParameters,
"application/json",
types.MainCategoryPost201Schema
>
|
lib.OutgoingEmptyResponse<
403,
parameters.CreateMainCategory403ResponseParameters
>
;
export function isGetSubCategoriesAuthentication<A extends ServerAuthentication>(
authentication: Partial<GetSubCategoriesAuthentication<A>>,
): authentication is GetSubCategoriesAuthentication<A> {
return authentication.apiToken !== undefined
}
export type GetSubCategoriesAuthentication<A extends ServerAuthentication> =
Pick<A, "apiToken">
;
export type GetSubCategoriesOperationHandler<A extends ServerAuthentication> =
(
incomingRequest: GetSubCategoriesIncomingRequest,
authentication: GetSubCategoriesAuthentication<A>,
) => GetSubCategoriesOutgoingResponse | Promise<GetSubCategoriesOutgoingResponse>
export type GetSubCategoriesIncomingRequest =
lib.IncomingEmptyRequest<parameters.GetSubCategoriesRequestParameters>
;
export type GetSubCategoriesOutgoingResponse =
lib.OutgoingJsonResponse<
200,
parameters.GetSubCategories200ResponseParameters,
"application/json",
types.SubCategoryMainCategoryId200GetSchema
>
;
export function isCreateSubCategoryAuthentication<A extends ServerAuthentication>(
authentication: Partial<CreateSubCategoryAuthentication<A>>,
): authentication is CreateSubCategoryAuthentication<A> {
return authentication.apiToken !== undefined
}
export type CreateSubCategoryAuthentication<A extends ServerAuthentication> =
Pick<A, "apiToken">
;
export type CreateSubCategoryOperationHandler<A extends ServerAuthentication> =
(
incomingRequest: CreateSubCategoryIncomingRequest,
authentication: CreateSubCategoryAuthentication<A>,
) => CreateSubCategoryOutgoingResponse | Promise<CreateSubCategoryOutgoingResponse>
export type CreateSubCategoryIncomingRequest =
lib.IncomingJsonRequest<
parameters.CreateSubCategoryRequestParameters,
"application/json",
types.SubCategoryMainCategoryIdPostRequestBodySchema
>
;
export type CreateSubCategoryOutgoingResponse =
lib.OutgoingJsonResponse<
201,
parameters.CreateSubCategory201ResponseParameters,
"application/json",
types.SubCategoryMainCategoryIdPost201Schema
>
|
lib.OutgoingEmptyResponse<
403,
parameters.CreateSubCategory403ResponseParameters
>
;
