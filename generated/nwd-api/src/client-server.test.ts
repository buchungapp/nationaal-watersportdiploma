// @generated by
//
//   ██████╗ ██████╗ ███████╗███╗   ██╗ █████╗ ██████╗ ██╗██╗  ██╗██████╗
//  ██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔══██╗██╔══██╗██║██║  ██║╚════██╗
//  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████║██████╔╝██║███████║ █████╔╝
//  ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║██╔══██║██╔═══╝ ██║╚════██║██╔═══╝
//  ╚██████╔╝██║     ███████╗██║ ╚████║██║  ██║██║     ██║     ██║███████╗
//   ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚══════╝
//   v0.1.6                                           -- www.OpenApi42.org
import assert from "assert/strict";
import test from "node:test";
import * as main from "./main.js";
import * as http from "http";
test("echo-via-get 200 application/json", async () => {
const server = new main.Server({
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
});
server.registerEchoViaGetOperation(async (incomingRequest, authentication) => {
{
const parameterValue = incomingRequest.parameters.message;
const valid = main.isParametersSchema(parameterValue);
assert.equal(valid, true);
}
return {
status: 200,
parameters: {
},
contentType: "application/json",
entity: () => main.mockGetSchema(),
}
});
let lastError: unknown;
const httpServer = http.createServer();
httpServer.addListener(
"request",
server.asRequestListener({
onError: (error) => lastError = error,
}),
);
await new Promise<void>((resolve) => httpServer.listen(resolve));
const address = httpServer.address();
assert(address != null && typeof address === "object")
const { port } = address;
const baseUrl = new URL(`http://localhost:${port}`);
try {
const operationResult = await main.echoViaGet(
{
contentType: null,
parameters: {
message: main.mockParametersSchema(),
},
},
{},
{
baseUrl,
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
},
);
assert.ifError(lastError);
assert(operationResult.status === 200)
assert(operationResult.contentType === "application/json")
{
const entity = await operationResult.entity();
const valid = main.isGetSchema(entity);
assert.equal(valid, true);
}
}
finally {
await new Promise<void>((resolve, reject) =>
httpServer.close((error) => (error == null ? resolve() : reject(error))),
);
}
});
test("echo application/json 200 application/json", async () => {
const server = new main.Server({
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
});
server.registerEchoOperation(async (incomingRequest, authentication) => {
assert.equal(incomingRequest.contentType, "application/json")
{
const entity = await incomingRequest.entity();
const valid = main.isRequestBodySchema(entity);
assert.equal(valid, true);
}
return {
status: 200,
parameters: {
},
contentType: "application/json",
entity: () => main.mockPostSchema(),
}
});
let lastError: unknown;
const httpServer = http.createServer();
httpServer.addListener(
"request",
server.asRequestListener({
onError: (error) => lastError = error,
}),
);
await new Promise<void>((resolve) => httpServer.listen(resolve));
const address = httpServer.address();
assert(address != null && typeof address === "object")
const { port } = address;
const baseUrl = new URL(`http://localhost:${port}`);
try {
const operationResult = await main.echo(
{
contentType: "application/json",
parameters: {},
entity: () => main.mockRequestBodySchema(),
},
{},
{
baseUrl,
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
},
);
assert.ifError(lastError);
assert(operationResult.status === 200)
assert(operationResult.contentType === "application/json")
{
const entity = await operationResult.entity();
const valid = main.isPostSchema(entity);
assert.equal(valid, true);
}
}
finally {
await new Promise<void>((resolve, reject) =>
httpServer.close((error) => (error == null ? resolve() : reject(error))),
);
}
});
