// @generated by
//
//   ██████╗ ██████╗ ███████╗███╗   ██╗ █████╗ ██████╗ ██╗██╗  ██╗██████╗
//  ██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔══██╗██╔══██╗██║██║  ██║╚════██╗
//  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████║██████╔╝██║███████║ █████╔╝
//  ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║██╔══██║██╔═══╝ ██║╚════██║██╔═══╝
//  ╚██████╔╝██║     ███████╗██║ ╚████║██║  ██║██║     ██║     ██║███████╗
//   ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚══════╝
//   v0.2.1                                           -- www.OpenApi42.org
import assert from "assert/strict";
import test from "node:test";
import * as main from "./main.js";
import * as http from "http";
type ServerAuthentication = {
apiToken: boolean,
};
test("get-main-categories 200 application/json", async () => {
const server = new main.Server<ServerAuthentication>({
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
});
server.registerGetMainCategoriesOperation(async (incomingRequest, authentication) => {
return {
status: 200,
parameters: {
},
contentType: "application/json",
entity: () => main.mockMainCategory200GetSchema(),
}
});
server.registerApiTokenAuthentication((credential) => credential === "super-secret-api-key")
let lastError: unknown;
const httpServer = http.createServer();
httpServer.addListener(
"request",
server.asRequestListener({
onError: (error) => lastError = error,
}),
);
await new Promise<void>((resolve) => httpServer.listen(resolve));
const address = httpServer.address();
assert(address != null && typeof address === "object")
const { port } = address;
const baseUrl = new URL(`http://localhost:${port}`);
try {
const operationResult = await main.getMainCategories(
{
contentType: null,
parameters: {},
},
{
apiToken: "super-secret-api-key",
},
{
baseUrl,
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
},
);
assert.ifError(lastError);
assert(operationResult.status === 200)
assert(operationResult.contentType === "application/json")
{
const entity = await operationResult.entity();
const valid = main.isMainCategory200GetSchema(entity);
assert.equal(valid, true);
}
}
finally {
await new Promise<void>((resolve, reject) =>
httpServer.close((error) => (error == null ? resolve() : reject(error))),
);
}
});
test("create-main-category application/json 201 application/json", async () => {
const server = new main.Server<ServerAuthentication>({
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
});
server.registerCreateMainCategoryOperation(async (incomingRequest, authentication) => {
assert.equal(incomingRequest.contentType, "application/json")
{
const entity = await incomingRequest.entity();
const valid = main.isMainCategoryPostRequestBodySchema(entity);
assert.equal(valid, true);
}
return {
status: 201,
parameters: {
},
contentType: "application/json",
entity: () => main.mockMainCategoryPost201Schema(),
}
});
server.registerApiTokenAuthentication((credential) => credential === "super-secret-api-key")
let lastError: unknown;
const httpServer = http.createServer();
httpServer.addListener(
"request",
server.asRequestListener({
onError: (error) => lastError = error,
}),
);
await new Promise<void>((resolve) => httpServer.listen(resolve));
const address = httpServer.address();
assert(address != null && typeof address === "object")
const { port } = address;
const baseUrl = new URL(`http://localhost:${port}`);
try {
const operationResult = await main.createMainCategory(
{
contentType: "application/json",
parameters: {},
entity: () => main.mockMainCategoryPostRequestBodySchema(),
},
{
apiToken: "super-secret-api-key",
},
{
baseUrl,
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
},
);
assert.ifError(lastError);
assert(operationResult.status === 201)
assert(operationResult.contentType === "application/json")
{
const entity = await operationResult.entity();
const valid = main.isMainCategoryPost201Schema(entity);
assert.equal(valid, true);
}
}
finally {
await new Promise<void>((resolve, reject) =>
httpServer.close((error) => (error == null ? resolve() : reject(error))),
);
}
});
test("get-sub-categories 200 application/json", async () => {
const server = new main.Server<ServerAuthentication>({
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
});
server.registerGetSubCategoriesOperation(async (incomingRequest, authentication) => {
{
const parameterValue = incomingRequest.parameters.mainCategoryId;
const valid = main.isParametersSchema(parameterValue);
assert.equal(valid, true);
}
return {
status: 200,
parameters: {
},
contentType: "application/json",
entity: () => main.mockSubCategoryMainCategoryId200GetSchema(),
}
});
server.registerApiTokenAuthentication((credential) => credential === "super-secret-api-key")
let lastError: unknown;
const httpServer = http.createServer();
httpServer.addListener(
"request",
server.asRequestListener({
onError: (error) => lastError = error,
}),
);
await new Promise<void>((resolve) => httpServer.listen(resolve));
const address = httpServer.address();
assert(address != null && typeof address === "object")
const { port } = address;
const baseUrl = new URL(`http://localhost:${port}`);
try {
const operationResult = await main.getSubCategories(
{
contentType: null,
parameters: {
mainCategoryId: main.mockParametersSchema(),
},
},
{
apiToken: "super-secret-api-key",
},
{
baseUrl,
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
},
);
assert.ifError(lastError);
assert(operationResult.status === 200)
assert(operationResult.contentType === "application/json")
{
const entity = await operationResult.entity();
const valid = main.isSubCategoryMainCategoryId200GetSchema(entity);
assert.equal(valid, true);
}
}
finally {
await new Promise<void>((resolve, reject) =>
httpServer.close((error) => (error == null ? resolve() : reject(error))),
);
}
});
test("create-sub-category application/json 201 application/json", async () => {
const server = new main.Server<ServerAuthentication>({
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
});
server.registerCreateSubCategoryOperation(async (incomingRequest, authentication) => {
{
const parameterValue = incomingRequest.parameters.mainCategoryId;
const valid = main.isParametersSchema(parameterValue);
assert.equal(valid, true);
}
assert.equal(incomingRequest.contentType, "application/json")
{
const entity = await incomingRequest.entity();
const valid = main.isSubCategoryMainCategoryIdPostRequestBodySchema(entity);
assert.equal(valid, true);
}
return {
status: 201,
parameters: {
},
contentType: "application/json",
entity: () => main.mockSubCategoryMainCategoryIdPost201Schema(),
}
});
server.registerApiTokenAuthentication((credential) => credential === "super-secret-api-key")
let lastError: unknown;
const httpServer = http.createServer();
httpServer.addListener(
"request",
server.asRequestListener({
onError: (error) => lastError = error,
}),
);
await new Promise<void>((resolve) => httpServer.listen(resolve));
const address = httpServer.address();
assert(address != null && typeof address === "object")
const { port } = address;
const baseUrl = new URL(`http://localhost:${port}`);
try {
const operationResult = await main.createSubCategory(
{
contentType: "application/json",
parameters: {
mainCategoryId: main.mockParametersSchema(),
},
entity: () => main.mockSubCategoryMainCategoryIdPostRequestBodySchema(),
},
{
apiToken: "super-secret-api-key",
},
{
baseUrl,
validateIncomingParameters: false,
validateIncomingEntity: false,
validateOutgoingParameters: false,
validateOutgoingEntity: false,
},
);
assert.ifError(lastError);
assert(operationResult.status === 201)
assert(operationResult.contentType === "application/json")
{
const entity = await operationResult.entity();
const valid = main.isSubCategoryMainCategoryIdPost201Schema(entity);
assert.equal(valid, true);
}
}
finally {
await new Promise<void>((resolve, reject) =>
httpServer.close((error) => (error == null ? resolve() : reject(error))),
);
}
});
