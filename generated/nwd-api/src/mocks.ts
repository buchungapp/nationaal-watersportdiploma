// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
// v0.11.4                         -- www.JsonSchema42.org
//
import * as types from "./types.js";
const depthCounters: Record<string, number> = {};
export interface MockGeneratorOptions {
maximumDepth?: number;
}
const defaultMockGeneratorOptions = {
maximumDepth: 1,
}
/**
* @see {@link file:///home/elmerbulthuis/workspace/nationaal-watersportdiploma/specifications/nwd-api.yaml#/paths/%2Fecho/post/responses/200/content/application%2Fjson/schema}
*/
export function mockResponsesSchema(options: MockGeneratorOptions = {}): types.ResponsesSchema {
const configuration = {
...defaultMockGeneratorOptions,
...options,
};
depthCounters["0"] ??= 0;
try {
depthCounters["0"]++;
return (mockMessageContainer());
}
finally {
depthCounters["0"]--;
}
}
/**
* @see {@link file:///home/elmerbulthuis/workspace/nationaal-watersportdiploma/specifications/nwd-api.yaml#/components/schemas/message-container}
*/
export function mockMessageContainer(options: MockGeneratorOptions = {}): types.MessageContainer {
const configuration = {
...defaultMockGeneratorOptions,
...options,
};
depthCounters["1"] ??= 0;
try {
depthCounters["1"]++;
return (
{
"message": mockMessage(),
}
);
}
finally {
depthCounters["1"]--;
}
}
/**
* @see {@link file:///home/elmerbulthuis/workspace/nationaal-watersportdiploma/specifications/nwd-api.yaml#/components/schemas/message-container/properties/message}
*/
export function mockMessage(options: MockGeneratorOptions = {}): types.Message {
const configuration = {
...defaultMockGeneratorOptions,
...options,
};
depthCounters["2"] ??= 0;
try {
depthCounters["2"]++;
return (randomString({"lengthOffset":1,"lengthRange":15,"chars":"abcdefghijklmnopqrstuvwxyz"}));
}
finally {
depthCounters["2"]--;
}
}
/**
* @see {@link file:///home/elmerbulthuis/workspace/nationaal-watersportdiploma/specifications/nwd-api.yaml#/paths/%2Fecho/post/requestBody/content/application%2Fjson/schema}
*/
export function mockRequestBodySchema(options: MockGeneratorOptions = {}): types.RequestBodySchema {
const configuration = {
...defaultMockGeneratorOptions,
...options,
};
depthCounters["3"] ??= 0;
try {
depthCounters["3"]++;
return (mockMessageContainer());
}
finally {
depthCounters["3"]--;
}
}
let seed = 1;
function nextSeed() {
// https://en.wikipedia.org/wiki/Linear_congruential_generator
// https://statmath.wu.ac.at/software/src/prng-3.0.2/doc/prng.html/Table_LCG.html
const p = Math.pow(2, 31) - 1;
const a = 950706376;
const b = 0;
seed = (a * seed + b) % p;
return seed;
}
interface RandomStringArguments {
lengthOffset: number,
lengthRange: number,
chars: string,
}
function randomString({
lengthOffset,
lengthRange,
chars,
}: RandomStringArguments) {
const length = lengthOffset + nextSeed() % lengthRange;
let value = ""
while(value.length < length) {
value += chars[nextSeed() % chars.length];
}
return value;
}
interface RandomNumberArguments {
isMinimumInclusive: boolean;
isMaximumInclusive: boolean;
minimumValue: number;
maximumValue: number;
precisionOffset: number,
precisionRange: number,
}
function randomNumber({
isMinimumInclusive,
isMaximumInclusive,
minimumValue,
maximumValue,
precisionOffset,
precisionRange,
}: RandomNumberArguments) {
const precision = precisionOffset + nextSeed() % precisionRange;
const inclusiveMinimumValue = isMinimumInclusive ? minimumValue : minimumValue + (1 / precision);
const inclusiveMaximumValue = isMaximumInclusive ? maximumValue : maximumValue - (1 / precision);
const valueOffset = inclusiveMinimumValue * precision;
const valueRange = (inclusiveMaximumValue - inclusiveMinimumValue) * precision;
const value = (valueOffset + nextSeed() % valueRange) / precision;
return value;
}
interface RandomArrayArguments<T> {
elementFactory: () => T;
lengthOffset: number;
lengthRange: number;
}
function randomArray<T>({
elementFactory,
lengthOffset,
lengthRange,
}: RandomArrayArguments<T>) {
const length = lengthOffset + nextSeed() % lengthRange;
const value = new Array<T>();
while(value.length < length) {
value.push(elementFactory());
}
return value;
}
