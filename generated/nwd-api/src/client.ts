// @generated by
//
//   ██████╗ ██████╗ ███████╗███╗   ██╗ █████╗ ██████╗ ██╗██╗  ██╗██████╗
//  ██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔══██╗██╔══██╗██║██║  ██║╚════██╗
//  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████║██████╔╝██║███████║ █████╔╝
//  ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║██╔══██║██╔═══╝ ██║╚════██║██╔═══╝
//  ╚██████╔╝██║     ███████╗██║ ╚████║██║  ██║██║     ██║     ██║███████╗
//   ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝╚══════╝
//   v0.1.3                                           -- www.OpenApi42.org
import { Router } from "goodrouter";
import * as parameters from "./parameters.js";
import * as types from "./types.js";
import * as validators from "./validators.js";
import * as parsers from "./parsers.js";
import * as lib from "oa42-lib";
export interface ClientOptions {
baseUrl?: URL;
validateIncomingEntity?: boolean;
validateIncomingParameters?: boolean;
validateOutgoingEntity?: boolean;
validateOutgoingParameters?: boolean;
}
export const defaultClientOptions = {
validateIncomingEntity: true,
validateIncomingParameters: true,
validateOutgoingEntity: false,
validateOutgoingParameters: false,
};
const router = new Router({
parameterValueDecoder: value => value,
parameterValueEncoder: value => value,
}).loadFromJson({"templatePairs":[[1,[["/echo",null]]]]});
/**
Send a message via GET and get your message back in a message-container
Send a message and get the same message back!
*/
export async function echoViaGet(
outgoingRequest: EchoViaGetOutgoingRequest,
credentials: unknown,
options: ClientOptions = defaultClientOptions,
): Promise<EchoViaGetIncomingResponse> {
const {
baseUrl,
validateIncomingEntity,
validateIncomingParameters,
validateOutgoingEntity,
validateOutgoingParameters,
} = options;
if(baseUrl == null) {
throw new Error("please set baseUrl");
}
const pathParameters = {};
const queryParameters = {};
const requestHeaders = new Headers();
const cookieParameters = {};
if(validateOutgoingParameters) {
if(!parameters.isEchoViaGetRequestParameters(outgoingRequest.parameters)) {
throw new lib.ClientRequestParameterValidationFailed();
}
}
lib.addParameter(
queryParameters,
"message",
outgoingRequest.parameters.message as unknown as string,
);
const path =
router.stringifyRoute(
1,
pathParameters,
) +
lib.stringifyParameters(
queryParameters,
"?", "&", "=",
);
const cookie = lib.stringifyParameters(
cookieParameters,
"", "; ", "=",
);
if(cookie !== ""){
requestHeaders.append("set-cookie", cookie);
}
const url = new URL(path, baseUrl);
let body: BodyInit | null;
body = null;
const requestInit: RequestInit = {
headers: requestHeaders,
method: "GET",
redirect: "manual",
body,
};
const fetchResponse = await fetch(url, requestInit);
const responseContentType =
fetchResponse.headers.get("content-type");
let incomingResponse: EchoViaGetIncomingResponse;
switch(fetchResponse.status) {
case 200:
{
const responseParameters = {
} as parameters.EchoViaGet200ResponseParameters;
if(validateIncomingParameters) {
if(!parameters.isEchoViaGet200ResponseParameters(responseParameters)) {
throw new lib.ClientResponseParameterValidationFailed();
}
}
if (responseContentType == null) {
throw new lib.MissingClientResponseContentType();
}
switch(responseContentType) {
case "application/json":
{
const responseBody = fetchResponse.body;
if (responseBody == null) {
throw new Error("expected body");
}
const stream = (signal?: AbortSignal) => lib.fromReadableStream(
responseBody,
signal
);
const mapAssertEntity = (entity: unknown) => {
if(!validators.isGetSchema(entity)) {
throw new lib.ClientResponseEntityValidationFailed();
}
return entity;
};
incomingResponse = {
status: fetchResponse.status,
contentType: responseContentType,
parameters: responseParameters,
stream: (signal) => {
return stream(signal)
},
entities(signal) {
let entities = lib.deserializeJsonEntities(
stream,
signal,
) as AsyncIterable<types.GetSchema>;
if(validateIncomingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return entities;
},
entity() {
let entity = lib.deserializeJsonEntity(
stream
) as Promise<types.GetSchema>;
if(validateIncomingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return entity;
},
}
break;
}
default:
throw new lib.Unreachable();
}
break;
}
default:
throw new lib.Unreachable();
}
return incomingResponse;
}
export type EchoViaGetOutgoingRequest =
lib.OutgoingEmptyRequest<parameters.EchoViaGetRequestParameters>
;
export type EchoViaGetIncomingResponse =
lib.IncomingJsonResponse<
200,
parameters.EchoViaGet200ResponseParameters,
"application/json",
types.GetSchema
>
;
/**
Send a message
Send a message and get the same message back!
*/
export async function echo(
outgoingRequest: EchoOutgoingRequest,
credentials: unknown,
options: ClientOptions = defaultClientOptions,
): Promise<EchoIncomingResponse> {
const {
baseUrl,
validateIncomingEntity,
validateIncomingParameters,
validateOutgoingEntity,
validateOutgoingParameters,
} = options;
if(baseUrl == null) {
throw new Error("please set baseUrl");
}
const pathParameters = {};
const queryParameters = {};
const requestHeaders = new Headers();
const cookieParameters = {};
if(validateOutgoingParameters) {
if(!parameters.isEchoRequestParameters(outgoingRequest.parameters)) {
throw new lib.ClientRequestParameterValidationFailed();
}
}
const path =
router.stringifyRoute(
1,
pathParameters,
) +
lib.stringifyParameters(
queryParameters,
"?", "&", "=",
);
const cookie = lib.stringifyParameters(
cookieParameters,
"", "; ", "=",
);
if(cookie !== ""){
requestHeaders.append("set-cookie", cookie);
}
const url = new URL(path, baseUrl);
let body: BodyInit | null;
switch(outgoingRequest.contentType){
case "application/json": {
requestHeaders.append("content-type", outgoingRequest.contentType);
const mapAssertEntity = (entity: unknown) => {
if(!validators.isRequestBodySchema(entity)) {
throw new lib.ClientResponseEntityValidationFailed();
}
return entity;
};
let stream: AsyncIterable<Uint8Array>;
if("stream" in outgoingRequest) {
stream = outgoingRequest.stream(undefined);
}
else if("entities" in outgoingRequest) {
let entities = outgoingRequest.entities(undefined);
if(validateOutgoingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
stream = lib.serializeJsonEntities(entities);
}
else if("entity" in outgoingRequest) {
let entity = outgoingRequest.entity();
if(validateOutgoingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
stream = lib.serializeJsonEntity(entity);
}
else {
throw new lib.Unreachable();
}
body = await lib.collectStream(stream);
break;
}
default:
throw new lib.Unreachable();
}
const requestInit: RequestInit = {
headers: requestHeaders,
method: "POST",
redirect: "manual",
body,
};
const fetchResponse = await fetch(url, requestInit);
const responseContentType =
fetchResponse.headers.get("content-type");
let incomingResponse: EchoIncomingResponse;
switch(fetchResponse.status) {
case 200:
{
const responseParameters = {
} as parameters.Echo200ResponseParameters;
if(validateIncomingParameters) {
if(!parameters.isEcho200ResponseParameters(responseParameters)) {
throw new lib.ClientResponseParameterValidationFailed();
}
}
if (responseContentType == null) {
throw new lib.MissingClientResponseContentType();
}
switch(responseContentType) {
case "application/json":
{
const responseBody = fetchResponse.body;
if (responseBody == null) {
throw new Error("expected body");
}
const stream = (signal?: AbortSignal) => lib.fromReadableStream(
responseBody,
signal
);
const mapAssertEntity = (entity: unknown) => {
if(!validators.isPostSchema(entity)) {
throw new lib.ClientResponseEntityValidationFailed();
}
return entity;
};
incomingResponse = {
status: fetchResponse.status,
contentType: responseContentType,
parameters: responseParameters,
stream: (signal) => {
return stream(signal)
},
entities(signal) {
let entities = lib.deserializeJsonEntities(
stream,
signal,
) as AsyncIterable<types.PostSchema>;
if(validateIncomingEntity) {
entities = lib.mapAsyncIterable(entities, mapAssertEntity);
}
return entities;
},
entity() {
let entity = lib.deserializeJsonEntity(
stream
) as Promise<types.PostSchema>;
if(validateIncomingEntity) {
entity = lib.mapPromisable(entity, mapAssertEntity);
}
return entity;
},
}
break;
}
default:
throw new lib.Unreachable();
}
break;
}
default:
throw new lib.Unreachable();
}
return incomingResponse;
}
export type EchoOutgoingRequest =
lib.OutgoingJsonRequest<
parameters.EchoRequestParameters,
"application/json",
types.RequestBodySchema
>
;
export type EchoIncomingResponse =
lib.IncomingJsonResponse<
200,
parameters.Echo200ResponseParameters,
"application/json",
types.PostSchema
>
;
